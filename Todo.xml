<?xml-stylesheet type="text/xsl" href="XSL/Todo.xsl" ?> 
<topics
	 xmlns:r="http://www.r-project.org">

<topic>
<title>Things To Note</title>
<items>
<item>
InitializeNVPTXTarget() and generating code for PTX.
</item>

<item>
The getGlobalVariable() functions and the setting of these values
don't behave as expected. The get() function gets the initial value.
The set values don't set the variable it already exists.
This will change in the future.
The get value doesn't get the new value, just the initialization value.
See tests/clone2.R
</item>

<item status="high">
Should use the pointer for the global variable to set it,
just like we do when we get it. We need the type.
<r:code>
library(Rllvm)
InitializeNativeTarget()
mod = Module("global")
mod[["status"]] = TRUE
</r:code>
doesn't set the value if the variable has already been created.
It only sets it the first time.
</item>

</items>
</topic>
<topic>


<items>
<item>
strings &amp; string constants.
</item>

<item>
Should m[["notexists"]] for a Module m raise an error or return NULL.
</item>

<item status="check">
getGlobalValue() of a pointer to a string  doesn't work.
See explorations/globalString.R and 
specifically 
<r:code>
getGlobalValue(m[["str1_p"]], ee) # does not work
</r:code>
Do we have to dereference the pointer to get the actual
address of the data?
Seems fixed now (in git: 19ca87e)
</item>

<item>
Function to link two or more modules
so that we can compile functions separately and then
allow them to refer to each other.
Perhaps hierarchies of modules?
Use addGlobalMapping() explicitly to connect one routine to another module?
No, use the Linker::LinkModules() method?
What about the need for external linkage, the declaration, etc.
when we make a call to the routine that isn't in the module.
<br/>
We can insert new modules into the execution engine. See addModule().
We also would like to pass the compiler a collection
of modules so that it can find existing Functions in those.
</item>

<item>
Rf_length and other routines not available via getNativeSymbolInfo()
except on OS X. Have to find another way to access them to be able to
invoke them from LLVM.
<xml:ns></xml:ns></item>

<item status="low">
Compile access to R connections.
</item>

<item>
Example of accessing a struct.
</item>

<item>
Example of working with an existing struct type in C
and compile code to operate on it.
Issues with ensuring alignment and padding if compiled by another compiler.
</item>

<item>
When converting SEXPs to and from GVs in C code,
use the actual target SEXP type and not just the generic type.
Similar/Related to registering routines with R and checking the types in a .Call().
</item>

<item>
varargs
</item>


<item>
Metadata
</item>

<item>
getTypeID should return the name of the type, not just the enum
value.
</item>

<item>
Function to allow putting a block at the end, i.e. the return block.
See llvmpy, (tests/JUTTutorial2.py)
Is this what is actually going on in that example or are we jumping to that block?
</item>


<item>
Write out [Done] bitcode, [Done] llvm module (IR or ?), 
shared object (need linker step - system or in LLVM API?)
See pycc.
</item>

<item>
structures
getStructName()  (getName() in R), 
getElementTypes equivalent to getStructElementType(), getStructNumElements() in C++.
How to create them?  structType() function in R.
</item>


<item>
Navigate/traverse the tree of blocks, instructions,
and the ability to remove and insert instructions and
blocks.
<br/>
C code to erase from parent for BasicBlock and Instruction.
</item>



<item>
In the TU, ExecutionEngine create method has an NA for the type of one of the parameters.
The type is there and the name of the type is also there, just not shown.
<r:code>
system.time({tu = parseTU("inst/TU/llvm.c.001t.tu")})
k = getClassNodes(tu)
m = getClassMethods(k[["llvm::ExecutionEngine"]])
rm = resolveType(m, tu)
</r:code>
</item>

<item>
In TU
<r:code>
m = getClassMethods(k[["llvm::BasicBlock"]])
<r:error>
Error in getClass("GCC::Node::offset_type") : 
  "GCC::Node::offset_type" is not a defined class
</r:error>
</r:code>
</item>

<item>
How do we get the names of the elements on a struct Type?
Do we add this in meta-data?
</item>

<item>
Methods for IRBuilder
<br/>
See the TU interface generation.
<br/>
CreateUnwind, CreateUnreachable
CreateSelect
CreateVAArg
CreatePtrDiff
CreateSwitch,
CreateIndirectBr, CreateAggregateRet, 
CreateInvoke,
CreateNSWAdd, NUWAdd, NSWSub, ...
CreateInBoundsGEP
CreateTrunc, CreateZExt, CreateSExt
CreatePHI
CreateInboundsGEP  (is this equivalent getGetElementPtr?)

[Done] CreateIsNull, CreateIsNotNull
[Done] CreateExtractElemet
[Done] CreateInsertElement
</item>

<item>
Also allow passing in a function pointer to an LLVM generated
routine as a type of argument, i.e. a function pointer.
For example, the distance computation where we specify the 
metric to use for the two observations.
<br/>
How do we specify that sort of type?
<br/>

</item>

<item>
Make certain that errors don't abort R.
</item>



<item>
create a GEP with inbounds.
<br/>
Need to specify the indices in the constructor.
Call IRBuilder-&gt;CreateInBoundsGEP
</item>

<item status="fix"> [Close but not working]
global variables. Get the value.  Write a routine to get them.  Can't
we do this generically.
<br/>
Use the ExecutionEngine and its  methods
<r:code>
library(Rllvm)
mod = Module("globalTest")
ee = ExecutionEngine(mod)
id = "i"
mod[[id]] = pi
mod[[id]]
ptr = Rllvm:::getPointerToGlobal(mod[[id]], ee)
type = getType(mod[[id]])
ty = getElementType(type)
getGlobalValue(mod[[id]], ee)
</r:code>
See tests/globalGet.R
</item>

<item>
When we specify the initializer for a global variable
and it is an array, we have to make certain the length of the 
array matches.  
Ensure this in createGlobalVariable() when val is specified.
</item>

<item>
function to create an opaque type, e.g. pointerType(opaqueType())
</item>


<item>
dump a module to a buffer.
or createPrintModulePass to our buffer.
<br/>
Is this just showModule()?
</item>

<!-- "Dones" -->

<item status="done">
Get module's name via getName() method.
</item>

<item status="done">
makeRFunction to create a wrapper for an LLVM routine.
</item>



<item status="done">
[Done] Read bitcode (.bc) into a Module.
readBitCode.
[Done] Should be able to read from a raw also.
</item>


<item status="done">
Call a generated routine via Rffi or .Call()/.C()
<br/>
Use getPointerToFunction().
See tests/rffiCall.Rdb.
Crashing now.
See the second example in rffiCall.Rdb
<br/>
</item>

<item status="done">
Within a routine, call an existing routine in a DSO.
<br/>
Need to help out the resolving of routines.
<br/>
Ideally we would like to call the R engine
to resolve a symbol. However, for now
we can require that the caller
register symbols or DLLs.
</item>

<item status="done">
Clone a module - see llvmpy
<br/>
clone() generic and method for Module.
</item>

<item status="done">
module to native assembly - is this the IR?
If so, then simply showModule() or as(module, "character").
For creating bit code, use writeBitcode
</item>

<item status="done">
From assembly string? Done?
ParseAssemblyString.
And from IR, use parseIR
</item>
<item status="done">
Get element type of a pointer, array or vector type.
getPointerElementType(), getVectorElementType(), getArrayElementType(), etc.
</item>

<item status="done">
Find out how to parse IR text into IR structures.
<br/>
ParseIRFile() in opt.cpp.
So Support/IRReader.h
<br/>
For BitCode, see  include/llvm/Bitcode/ReaderWriter.h
</item>

<item status="done">
IRBuilder has a $ method so we can use
 ir$createICmp(), ir$createRet(), etc.
a la C++ invocation.
</item>

<item status="done">
[YES] Does assigning to the global variable actually set it - YES!
<r:code>
library(Rllvm)
mod = Module("globalTest")
mod[["i"]] = pi
</r:code>
Doesn't seem to.
</item>

<item status="done">
When the routine's  return type is VoidType, make certain
we get a terminator.
<br/>
See fgets.Rdb and change the return type to VoidType
</item>

</items>
</topic>
</topics>
