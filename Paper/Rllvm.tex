\documentclass[article]{jss}
\usepackage{comment}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{shadows,trees}
\usepackage{fancyvrb}
\usepackage{cprotect}
\usepackage{listings}
\usepackage{spverbatim}

\usepackage[firstpage]{draftwatermark}
\SetWatermarkLightness{.95}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% declarations for jss.cls %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% To finish
% Memory management
% using different backends, e.g. PTX, C++
% assertions terminating R.  (compile without debug-assertions)
%  show() method for the parameters.
% make parseIR() and readBitcode() consisitent



%% almost as usual
\author{Duncan Temple Lang\\University of California at Davis}
\title{The \Rpkg{Rllvm} package: generating fast code in \R{} by compiling with \llvm.}

%% for pretty printing and a nice hypersummary also set:
\Plainauthor{Duncan Temple Lang}
\Plaintitle{The Rllvm package: generating fast code in R by compiling with LLVM.}
\Shorttitle{Rllvm}

%% an abstract and keywords
\Abstract{ 

The \Rpkg{Rllvm} package is an \R{} interface to the Low-Level Virtual
Machine (LLVM).  This is a compiler toolkit for generating native code
for different computational devices (e.g. CPUs and GPUs).  These tools
in \R{} allow us to explore compiling both \R{} code and also
domain-specific languages (DSLs).  They also allow us to exchange code
with other systems using an intermediate representation of the native
code.  This paper describes the computational model and functionality
provided by \Rpkg{Rllvm} and illustrates these with examples of
low-level compilation.  We leave discussion of  more general
strategies for compiling \R{} code to \Rpkg{RLLVMCompile}.
} 
\Keywords{\R, \Rpkg{Rllvm} package, compiled code}
\Plainkeywords{R, RCIndex} %% without formatting
%% at least one keyword must be supplied

%% publication information
%% NOTE: Typically, this can be left commented and will be filled out by the technical editor
%% \Volume{13}
%% \Issue{9}
%% \Month{September}
%% \Year{2004}
%% \Submitdate{2004-09-29}
%% \Acceptdate{2004-09-29}

%% The address of (at least) one author should be given
%% in the following format:
\Address{
  Duncan Temple Lang\\
  4210 Math Sciences Building, \\
  University of California at Davis \\
  One Shields Avenue\\
  Davis, CA 95616\\
  E-mail: \email{duncan@r-project.org}\\
  URL: \url{http://www.omegahat.org}
}


\usepackage[T1]{fontenc} 
\catcode`\_=12

\input{jssMacros}
\def\RClang{\Rpkg{RCIndex}}
\def\Rllvm{\Rpkg{Rllvm}}
\def\IR{intermediate representation}
\def\Ins#1{\textbf{#1}}
\def\LLVMAttr#1{\texttt{#1}}

\begin{document}


\section{Overview and Motivation}\label{sec:Introduction}

The potential readers of this paper are people who are interested in
exploring how to create machine code directly within R for either
compiling R code or for developing domain specific languages in R.
We are using this to compile simple functions in R for speed 
and also to get them to run on the GPU to take advantage 
of massively parallel architectures.

This is more of a manual about how to program with the
\Rpkg{Rllvm}~\cite{bib:Rllvm} package than what we can do with it our
how we compile \R{}~\cite{bib:R} code.  We will explain some of this
using example code from the \Rpkg{RLLVMCompile}~\cite{bib:RLLVMCompile} package. However, this
is not a paper that describes that package and its compilation
approach.

In many respects, this article is an overview of what the \llvm~\cite{bib:llvm}
API provides for applications which use it. We describe the concepts,
classes and methods in that API, but in terms of how we manipulate these
in \R.

We will show how we can call existing \C{} routines using a
combination of \RClang{} and \Rllvm.  We also show how we can compile
simple functions such as the fibonacci sequence.  Similarly, we'll
show how to compile simple loops which can remove the need to write
vectorized code.  We'll show how to write a simple DSL, e.g. map a
BUGS hierarchical model to a sampler. (Too ambitious.)


We'll show how we can generate code for different input types
and so think of the high-level code as a template.
(This is done for the sort routine in C code in qsort.c by redefining the
type NUMERIC.

Show how to make code use multiple cores directly, with shared data?

Some readers may say the examples are unrealistic as \R{} already has
fast code to implement, e.g., \Rfunc{sum} and so on.  The point is not
to compete with those existing functions that are implemented in
C. Rather, the point is to say that we could implement them in \R{}
code, make them more flexible so that they can run on multiple
processors, take advantage of contextual information, e.g. no \na's,
reusing memory. The examples are intentionally simple to focus on how
we generate the equivalent machine code.


The purpose of writing this article is to hopefully encourage and
enable some \R{} programmers to experiment with improving \R's
efficiency by experimenting with different compilation strategies,
either for \R{} code or other domain specific languages (DSLs) within
R.

We'll use examples from the ``Writing R extensions manual'' also used
in the \Rpkg{Rcpp}~\cite{bib:Rcpp} package to facilitate comparison.


The focus of the paper is generating native code in \R{} using \llvm.
However, before we do this, we have to understand the essential
concepts of \llvm.  Therefore, we start by exploring \llvm{} by
working with previously generated code. %We will see how we can We may
%not regulary need all of these tools for querying \llvm{} objects when
%we generate code, but they allow us to 


\section[LLVM Concepts]{\llvm concepts}
% Start with a very simple approach which is to read existing
% IR code into R and call it.

Perhaps the easiest way to start exploring the \R{} interface to
\llvm{} is to to load some previously compiled native routines into an
\R{} session and call them from \R. 
We can generate the code for these routines in various different ways,
but perhaps the simplest to understand is to create the \IR{} code
from manually written \C{} code using \clang{} and
\ShFlag{-emit-llvm}. We use the shell command
\begin{ShCode}
clang -S -emit-llvm -o fib.ll fib.c
\end{ShCode}
Similarly, we could generate the code as binary ``bitcode''
using
\begin{ShCode}
clang  -emit-llvm fib.c -c -o fib.bc
\end{ShCode}
Later, we will see how to create this code within \R{} itself.
However, for now, it is  only important that we have this code.
Our purpose in this section is to get up and running with \llvm{}
in \R{} in order to introduce some of the essential high-level concepts.

% what about compiling as a .so!

\subsection{Modules}
We can read the code in \file{fib.bc} into \R{} using
%XXX file is not in this directory
%XXX use a module that has more than one routine.
% mod = readBitcode("../../explorations/fib.bc")  
\begin{RCode}
mod = readBitcode("fib.bc")  
\end{RCode}
The result is an object of class \Rclass{Module}.  This is a reference
to the corresponding \Cpp{} class in the \llvm{} API.  A module is a
container for a collection of routines, global variables and generally
related compiled elements.  We can have multiple separate modules in
an \R{} session simultaneously.  We can even clone a module to create
two separate instances of it.

In some ways, we can think of a \Rclass{Module} in \R{} like a \Rclass{list}.
We can query the names of its elements with 
\begin{RCode}
names(mod)
\end{RCode}
%XXX change to reflect two or more routines.
\begin{ROutput}
[1] "fib"  
\end{ROutput}

We can access any of the elements in the module using the
\Rdollar{} operator, e.g. 
\begin{RCode}
mod$fib  
\end{RCode}
%$
This returns a reference to the native object in the \llvm{} module.
In this case, we have a reference to a \Rclass{Function} object.
This represents the routine we can call from \R.

We can query the number and type of the arguments of the routine
with 
\begin{RCode}
getParameters(mod$fib)  
\end{RCode}
%$
This tells us that there is a single parameter which should be
an integer value.

\subsection{Invoking a routine}

We can call this routine using the \Rfunc{.llvm} function:
\begin{RCode}
.llvm(mod$fib, 30)  
\end{RCode}
%$
% Following is not true with binary code, only ll code.
%We should note  that the first time we run this routine,  \llvm{} 
%XXX reading fib.ll has #0 in it. and attributes #0. Need to remove
%these.
The intent is that the \Rfunc{.llvm} is similar to the \Rfunc{.C} and
\Rfunc{.Call} routines in \R.  We specify the routine to invoke and
pass it any arguments.  Unlike the \Rfunc{.C} and \Rfunc{.Call}
interfaces generally, \Rfunc{.llvm} knows the types of the parameters
and so can coerce the arguments from the \R{} call to the appropriate
type to pass to the routine.
In this example, \Rfunc{.llvm} coerces the value $30$ from 
its inherent \Rclass{numeric} type to an integer, consistent with the
native type expected by the \Cfunc{fib} routine.

Rather than calling \Rfunc{.llvm} directly each time we want to invoke
a particular routine, we can create an \R{} function that provides a
simpler interface.  The function \Rfunc{makeRFunction} does this for
us by querying the \llvm{} routine for its parameters and creating a
simple proxy.



\subsection{Execution Engine}

Each time we invoke this routine, \Rllvm creates a new, what is called
an, \Rclass{ExecutionEngine}. We improve matters by creating 
a single execution engine object and using this in each call
to \Rfunc{.llvm}. We do this via a call to \Rfunc{ExecutionEngine},
passing it the module on which we want it operate. % can have morethan
                                % one module. XXX Make this add the module
\begin{RCode}
ee = ExecutionEngine(mod)  
\end{RCode}
We can then pass this via \Rfunc{.llvm}'s \Rarg{.ee} parameter, e.g.
\begin{RCode}
.llvm(mod$fib, 30, .ee = ee)  
\end{RCode}
%$
The overhead of creating a new execution engine each time can be quite
significant.  Therefore, it is good to explicitly create and pass
one in each call to \Rfunc{.llvm}. %XXX check this 


While the content doesn't matter to us for invoking the routine, the
\file{fib.ll} file contains the code shown in figure~\ref{fig:IRCodeDisplay}
intermediate representation (IR) form and is low-level code that
describes the routine and its instructions.  The content is similar in
nature to assembler code. This is why it is called low-level.
\begin{figure}
% show ../explorations/fib.ll
\lstinputlisting{../explorations/fib.ll} This is what is called  
  \caption{This is the code for the fibonacci function
in \llvm's intermediate representation (IR) form.
This shows the module and the routine named \texttt{@fib}.
The type information of the parameters and return value is also show.
The body of the routine consists of several blocks, each identified
by a label, e.g. \texttt{entry:} and \texttt{if.then}.
Each block contains instructions that do the work of the routine.
The final instruction in each block is either a branch (\Ins{op})
to another block of instructions, or an explicit return (\Ins{ret})
instruction to exit the call to this routine.
}\label{fig:IRCodeDisplay}
\end{figure}

% return type.
The \Rfunc{.llvm} function queries the routine we are calling and
determines both the types of the parameters and also the return type.
It does this with \Rfunc{getReturnType}.  This returns an explicit
\Rclass{Type} object. These are vitally important in \llvm{} and
so we'll take the opportunity to understand them a little better.

\input{types}



\subsection{Block}
A \Rclass{Block} is a container for one or more related instructions.
These instructions are evaluated in order sequentially.  The final
instruction must be either a branch to jump to another block of
instructions, or an explicit return instruction.

We can get the entire set of instructions within  a block
with \Rfunc{getBlockInstructions}.
Similarly, since a block is a container, we can also treat it like a list in \R.  We
can ask how many instructions it contains with \Rfunc{length} and
access the instructions by subsetting the block, e.g.
\begin{RCode}
 block[ ]  
 block[[2]]
\end{RCode}

We can retrieve the terminator instruction directly with
\Rfunc{getTerminator}.

\section{Instructions}
We have seen the hierarchy of modules containing routines which
contain blocks.  Instructions are the elements that perform the
operations in a routine.  There are many different types of
instructions such as to call another routine,
add two real-valued numbers, assign/store
a value to a variable, load the value of a variable,
access an element in an array or via a pointer,
compare two values (e.g. $<$, $>$, $\ge$)
branch to another block, cast a value to a different type, and so on.

Let's look at the \texttt{if.then} block in the
\Cfunc{fib} routine:
\begin{RCode}
b = getBlocks(mod$fib)$if.end
\end{RCode}
This contains nine instructions.
The first three appear as 
\begin{Verbatim}
  %3 = load i32* %n.addr, align 4
  %sub = sub nsw i32 %3, 1
  %call = call i32 @fib(i32 %sub)  
\end{Verbatim}
in the intermediate form in figure~\ref{fig:IRCodeDisplay}.
The first retrives the value from the variable n.addr, which 
is the address of the parameter named \Carg{n}.
The second subtracts $1$ from this value.
The final instruction calls the \Cfunc{fib} routine with this value.

Every instruction has a operation code (opcode) which identifies
the kind of operation. We can retrieve this with \Rfunc{getOpcode},
e.g.
\begin{RCode}
sapply(b[1:3], getOpcode)
\end{RCode}
\begin{ROutput}
load  sub call 
  27   10   48   
\end{ROutput}
As with types, the value of \Rfunc{getOpcode} is the value of the
\C{} enumerated constant and the name gives the symbolic name.


Every instruction has a type that tells us about its result. 
We can query this with \Rfunc{getType}. This returns a
\Rclass{Type} object which we discussed in section~\ref{sec:Types}.

Different types of instructions will have different contents,
i.e. elements that make up the instruction.
These are the operands.
We can query the number of operands in an instruction with \Rfunc{getNumOperands}
and then can access individual operands with the  list subsetting
operator, e.g.
\begin{RCode}
b[[2]][1]]
b[[2]][2]]
\end{RCode}
When we create instructions, we will call a particular
function corresponding to the specific kind of instruction
we want, passing it the inputs it requires.


This completes the brief overview of the essential elements of \llvm.
We have seen modules, routines/functions, types, blocks and
instructions.  We also saw the execution engine and how to 
invoke a routine created by \llvm.
% intermediate form and bit code.


\section{The basic steps of generating machine code}

We start with some parsed code.  To illustrate, consider computing the
sum of the elements of a vector. %better example that R doesn't
already do. A distribution function that can't be vectorized?%
% How about a bootstrap or call to replicate() and reuse the memory.
% Compile the loop to not need the vector to be expanded, but use a counter
% Call R's internal functions. Since a primitive

We need to create two routines corresponding to the \R{} functions.



%\section{Function class}
% parameters and attributes.



\subsection{IRBuilder}
To create working code with \llvm, we create instructions and add them
to a particular block.  The simplest way to do this is to use an
\Rclass{IRBuilder}.  This both creates the different types
instructions and inserts them into its current block.  We create an
\Rclass{IRBuilder} object with the constructor function of the same
name, i.e. \Rfunc{IRBuilder}.  Generally, we pass it the initial block
of a newly created \Rclass{Function} object.

This takes 
\begin{RCode}
mod = Module()
fun = Function("moveCars", Int32Type, list(Int32PtrType, Int32Type, Int32Type), mod)
start = Block(fun, "entry")
ir = IRBuilder(block)  
\end{RCode}

With the \Rclass{IRBuilder} created, we can now create instructions.
For example, to create a local variable named \Cvar{i}, we might
call
\begin{RCode}
iv = createLocalVariable(ir, Int32Type, "i")  
\end{RCode}
We'll explore creating instructions generally in the next
section. 

Because the \Rclass{IRBuilder} is used to create almost all
instructions, it is the first argument in the functions
that create instructions.
Some programmers may find it convenient or helpful to 
think of the instruction constructor functions
as ``methods'' of the \Rclass{IRBuilder} object and
to use the form
\begin{RCode}
ir$createStore(var, value)
\end{RCode}
to call these functions.
%$
This is the same as
\begin{RCode}
createStore(ir, var, value)
\end{RCode}

We could explicitly create the instruction separately and add it to
the relevant \Rclass{Block}.  The \Rclass{IRBuilder} combines these
two steps for us, using the currently active block and adding the
instruction to the end of that block.  When we want to generate
instructions for a different block, we set the active block in the
\Rclass{IRBuilder} using the \Rfunc{setInsertBlock} function.
For example, 
\begin{RCode}
ret = Block(fun, "return")
setInsertBlock(ir, ret)
\end{RCode}

Typically, we set the active block, generate all of the code for it
and then move to another block.  However, there are ocassions where we
have to switch between blocks. For this, it is convenient to retrieve
the current block with \Rfunc{getInsertBlock} so that we can switch
back to it at a later point.

We often work at the level of blocks. However, we can specify
individual instructions as the current insertion point
with \Rfunc{setInsertPoint}.%XXX make this so.

%Getting and inserting the insertion point.

%?Accessing the blocks (should we use [[ ]], by index, name?). Of a
%function or the ir builder?


% Constants

\subsection{Creating Instructions}
There are many 


\subsection{Branching}
% Doesn't need its own section.
We have already mentioned that every block has to have a terminator
and that it must be a return or a branch to another block.  We create
a branch with \Rfunc{createBranch}, passing it the \Rclass{IRBuilder}
and the block to which we want to jump. This adds the branch
instruction at the end of the current block in the \Rclass{IRBuilder}.


\subsection{Intermediate Representation and viewing the code}
% Seen this above

\Rfunc{showModule}

write code to file.
read it into R.

\Rfunc{verifyModule}

%\section{Verifying the generated code}



\section[Connecting LLVM and existing native routines]{Connecting \llvm{} and existing native routines}
% Registering native symbols.

\subsection{Optimization}
Passes, pass manager



\subsection{Global Variables}

%clone the module, create new ones with different execution engines.

\section[General LLVM functionality]{General \llvm{} functionality}

In addition to the specific functions for generating code,
there are some simple functions in \Rllvm{} that
allow us to control the \llvm{} and also find the
version information.
We can determine the version of the \llvm{} libraries
with which the \R{} package is compiled with
\begin{RCode}
llvmVersion()  
\end{RCode}
This can be important to determine what features are available
and what forms of code we can read.


We can also determine the different targets 
for which we can generate  code via the \Rfunc{getLLVMTargets}
function. This information is determined at installation time
and returned as a character vector  via 
\begin{RCode}
getLLVMTargets()
\end{RCode}
\begin{ROutput}
 [1] "X86"        "Sparc"      "PowerPC"    "ARM"        "Mips"      
 [6] "CellSPU"    "XCore"      "MSP430"     "CppBackend" "MBlaze"    
[11] "NVPTX"      "Hexagon"     
\end{ROutput}
Here we see that we can generate code for various different CPUs
and also \Cpp{} and \code{PTX} code for  Nividia GPUs (Graphics
Processor Units).

Other general top-level functions include 
shutdown, start/stop multi-threaded.

\section{Examples and Case Studies}

\input{../explorations/dnorm}


\section{Linking to other routines}
In generating an \llvm{} routine, we sometimes call another routine
that is available in a library or \R{} itself. In order for \llvm{} to
be able to access this routine, we have to provide it with the address
of the routine.  We do this with \Cfunc{llvmAddSymbol}.  We can pass
it either the name of the external routine or we can explicitly
resolve the address with \Rfunc{getNativeSymbolInfo} and then pass its
result.
For example, suppose we define a routine that uses the 
\C{} routine \Cfunc{fgets} for reading a line from a file.
We register this routine with \llvm{} via
\begin{RCode}
llvmAddSymbol('fgets')
\end{RCode}
If the routine was in a dynamically loaded library, we could be
more specific and resolve it as
\begin{RCode}
dll = dyn.load('code.so')
info = getNativeSymbolInfo('fgets', dll)
\end{RCode}
and then pass \Rvar{info} to \Rfunc{llvmAddSymbol}.

We can also use \Rfunc{llvmAddSymbol} to register a variable, and not
just routines.

%If we don't need DLL in \R{}, we can skip \Rfunc{dyn.load} and use
%\Rfunc{llvmLoadDLL} to load the compiled code directly into \llvm.


There are situations in which we want to generate an \llvm{} routine
and then pass it as an argument to another routine outside of the
\llvm{} compilation, e.g. to a routine in a DLL.  These are
function/routine pointers and are simply references to the routine.
They are similar to the function we pass to the \R{} functions
\Rfunc{lapply} or \Rfunc{by}.  They are used generally as callbacks
for asynchronous event handlers, to compare two elements in a general
sorting routine, and in numerical optimization routines to specify the
mathematical function and its gradient to be maximized.

To obtain the address of the \llvm{} routine, we use
\Rfunc{getPointerToFunction}.  We specify both the \Rclass{Function}
object identifying the \llvm{} routine and also the
\Rclass{ExecutionEngine} which hosts the particular instance of the
routine. 
A typical sequence of commands is 
\begin{RCode}
mod = Module()
f = Function(....)
# commands to define the body of f
ee = ExecutionEngine(mod)
getPointerToFunction(f, ee)
\end{RCode}
It is essential that the routine be associated with an
\Rclass{ExecutionEngine} so that it is compiled and instantiated.


%XXXXFinish example of optimization.

In some circumstances, we don't have a reference to the
\Rclass{Function} object. In these cases, we can access it with
\Rfunc{findFunction}, e.g.
\begin{RCode}
findFunction("dnorm", ee)
\end{RCode}
and then pass this to \Rfunc{getPointerToFunction}.

We can also get the address of a global variable in an execution
engine with \Rfunc{getPointerToGlobal}.


\section{Compiling the IR code}
% getPassManager
% passManager           
% addPass, addAnalysisPasses
% addPassesToEmitFile, stringRawOstream, rawFDOstream, formattedRawOstream


\section{Attributes on Routines and Parameters}
While the instructions define what a routine does, we can also provide
information to the \llvm{} compiler about both routines and individual
parameters to help it optimize the code.  We do this by setting
attributes on routines and/or parameters.  These attributes for
routines include characteristics such as inlining the code
(\LLVMAttr{AlwaysInline}, \LLVMAttr{InlineHint} and \LLVMAttr{NoInline}), whether the routine may throw
an exception or not (\LLVMAttr{NoUnwind}), whether to check memory access in the
routine (\verb+sanitize_memory+).
The entire set of possible attributes is available from the variable
\Rexpr{LLVMAttributes}. (This includes attributes
for both routines and parameters.)
%and whether the routine is likely to
%be called often (cold) and so influnce branch prediction.
We set an attribute on a routine with \Rfunc{setFuncAttributes}.
For example, 
\begin{RCode}
setFuncAttributes(sfun$fun, 
                  c("NoUnwind", "StackProtectReq", "ReadOnly"))
\end{RCode}
Specifying the values by name is short-hand for using the actual
constants in \Rvar{FuncAttributes}.
%$ % http://llvm.org/docs/LangRef.html#function-attributes
We can also query the attributes for a routine with
\Rfunc{getFuncAttributes}.

We can set attributes for any parameter and the
return type of a routine. % http://llvm.org/docs/LangRef.html#parameter-attributes
We do this with objects of class \Rclass{Argument}.
We get such an object via either the \Rfunc{getParameters} or 
by subsetting the \Rclass{Function} object by name or index.
Again, the actual values (or names) for the attributes are found in
\Rvar{LLVMAttributes}.
For example, we can set attributes on the pointer parameter \Cvar{x}
with
\begin{RCode}
v_dnorm = vfun$fun
setParamAttributes(v_dnorm$x, c('NoAlias', 'NoCapture'))
\end{RCode}

% What about querying the parameter attributes

\section{Metadata}
For the most part, the code we generate executes as we define it.
However, there are circumstances when we want or need to add metadata
to the code.  We can add debugging information or information that a
particular optimization pass might understand.  A very concrete
example of metadata is when we generate a routine for use as a kernel
routine to be run on a GPU (Graphical Processing Unit).
When we use \lib{nvvm} to transform the \llvm{} IR code to 
the GPU's PTX format, we need to identify the routine as being a
kernel routine that can be launched by a host. 
We do this via metadata on the routine.
We can specify this using the \Rfunc{setMetadata} function.
We have to use a name for the particular metadata that others are
expecting and will query.  This is just a convention.
For a PTX kernel, the identifier is \texttt{nvvm.annotation}.
We set the metadata on the \Rclass{Module} containing the 
kernel routine and we specify the routine which is a kernel
along with the kernel identifier string and the literal value 1 as an
integer.
We do this as
\begin{RCode}
m = Module()
fc = Function("foo", VoidType, list(a = FloatType), m)
setMetadata(m, "nvvm.annotation", list(fc, "kernel", 1L))
\end{RCode}
Each element of the metadata is a \Rclass{Value}.
\Rfunc{setMetadata} converts \R{} objects to \Rclass{Value}
objects as necessary. However, we can create this separately
if we need more control over how they are created,
and then use them in a call to \Rfunc{setMetadata}.
For example, the type of a string in the metadata 
is a special identifier -- \texttt{MetadataTyID}.
If we wanted an explicit string, we could create and set the metadata
with, for example,
\begin{RCode}
setMetadata(m, 'test', createStringConstant('my string'))
\end{RCode}

We can query metadata with \Rfunc{getMetadata}, e.g. 
\begin{RCode}
md = getMetadata(m, "nvvm.annotation")
\end{RCode}
The result is an object of clas \Rclass{NamedMDNode}.
This is a container of \Rclass{MDNode} objects
with as many elements as there are separate settings
for that particular identifier. In this case, there
is only one entry.
We can treat the \Rclass{NamedMDNode} object as if it were a list in
\R{} and query its \Rfunc{length} and subset it in the usual way, e.g.
\begin{RCode}
nv = md[[1]]
\end{RCode}

A \Rclass{MDNode} is also a container and again we can treat it as a
list. In this case, \Rvar{nv} contains the three elements we
set previously.  We can access these via the usual subsetting
operations. Each element is \Rclass{Value} object and we can query
it using the functions we have discussed throughout this paper.



\section{Different targets}
% Different back-ends

\section{Navigating the instruction hierarchy}
In many situations, we create (and insert) the blocks and instructions
in the appropriate order and end up with the code we want.  We can
then compile the module and use the routines.  However, it can be
useful to be able to find and query individual instructions, remove an
instruction, or insert a new instruction at a specific point.  This
may be necessary if we use an \R{} function to generate a routine and
we want to modify it after it has been created.  For example, we may
want to add debugging or logging information or replace a call in the
routine with a call to a different implementation.

We have seen that there is a container hierarchy of a \Rclass{Module}
containing one or more \Rclass{Function} objects, and each
\Rclass{Function} has one or more \Rclass{BasicBlock} objects which
contain the \Rclass{Instruction} objects.
We can retrieve an \Rclass{Function} object from a \Rclass{Module}
using \Rexpr{module\$functionName}.
%$
We can get a \Rclass{Function}'s \Rclass{BasicBlock}s with
\Rfunc{getBlocks}.  This returns a list of the block objects.
The names for the list come from the names of the blocks.
We can also query the name of a block with \Rfunc{getName}
so that we can find the block(s) of interest.

We can retrieve the list of \Rclass{Instruction} objects
within a block via \Rfunc{getBlockInstructions} or using
the syntactic abbreviation \Rexpr{block[]}.
The latter treats the \Rclass{BasicBlock} as a list and retrieves
all of its elements.  We can use this subsetting approach to access
individual \Rclass{Instruction} elements within the block, 
e.g. \Rexpr{block[[3]]}.

\Rfunc{getBlockInstructions} (and the subsetting method)
will, by default, coerce each generic instruction to the more specific
class for that instruction.
This ensures that we can use  methods defined for these
sub-classes of \Rclass{Instruction} but which do not apply for
the generic \Rclass{Instruction} class.
The coercion uses \Rfunc{getOpcode} to determine the name of the ``op code'' of 
the \Rclass{Instruction} to identify the corresponding class name.

\begin{comment}
Each element returned appears in \R{} as a generic
\Rclass{Instruction} object. 
This means that we can 
We can determine the nature of an
instruction by examing its ``op code'' with the function
\Rfunc{getOpcode}.  This returns a named integer value. The name tells
is the human-readable type while the integer is the enumeration
constant used in \Cpp.
For example, in our \Cfunc{v_dnorm} routine,
we can retrieve the op codes for the instructions
in the block  that implements the body of the \Ckeyword{for} loop with
\begin{RCode}
block = getBlocks(vfun$fun)[['for.body']]
sapply(block[], getOpcode)
\end{RCode}
The result is
\begin{ROutput}
         load          sext          load getelementptr 
           27            35            27            29 
         load          load          load          call 
           27            27            27            48 
         load          sext          load getelementptr 
           27            35            27            29 
        store          load           add         store 
           28            27             8            28 
           br 
            2 
\end{ROutput} 
%$
We can coerce the generic \Rclass{Instruction} object to a more 
specific class using \Rfunc{as}.
For example, the fourth instruction has an op code 
named \texttt{getelementptr}. This corresponds to the
\Rclass{GetElementPtrInst} class in \R.
\begin{RCode}
as(b[[4]], 'GetElementPtrInst')
\end{RCode}
\end{comment}


Rather than getting all the instructions in a block, we sometimes want
just the terminator.  For instance, we may want to add a new block and
change where this block branches to.  The function
\Rfunc{getTerminator} finds the terminator instruction in a block, if
the \Rclass{BasicBlock} has a terminator.  This is typically the last
instruction in a block but may not be.


Once we have an instruction object, we can query its contents. There
are numerous different types of instructions and they have different
properties and characteristics and so we will query them in
class-specific ways.  However, all instructions have the concept of
operands, i.e. elements that make up the instruction.  We can retrieve
the entire set of operands with \Rfunc{getOperands} or use the
subsetting operator to retrieve an individual operand, e.g.
\Rexpr{ins[[2]]}.  We can determine the number of operands with
\Rfunc{getNumOperands} or simply with the overloaded \Rfunc{length}
method.  This allows us to treat an \Rclass{Instruction} as if it were
a list.


While we typically add instructions via the \Rclass{IRBuilder}, we can
also manipulate them directly.  We can remove an instruction from a
block with \Rfunc{eraseFromParent}.  We can also insert an instruction
before or after another instruction with the functions
\Rfunc{insertBefore} and \Rfunc{insertAfter}, respectively.  We can
also use \Rfunc{moveBefore} to change the location of an existing
instruction.

When creating instructions with the \Rclass{IRBuilder}, each new
instruction is added after the current instruction in the current
block.  We can set the current block with \Rfunc{setInsertBlock} and
then new instructions are added to the end of this block.  We can use
\Rfunc{setInsertPoint} to specify the instruction after which new
instructions will be added.  These functions to specify the insertion
point and to reposition instructions give us a lot of flexibility to
organize code, both proactively and retroactively.


In addition to being able to traverse down the hierarchy of
\Rclass{BasicBlock}s and \Rclass{Instruction}s, we can also move up
the hierarchy with the \Rfunc{getParent} function.  This allows us to
retrieve a reference to an \Rclass{Instruction}'s \Rclass{BasicBlock}
and a \Rclass{BasicBlock}'s parent \Rclass{Module}.



\section[Querying LLVM]{Querying \llvm}
It is sometimes useful to be able to query and deploy aspects
of the \llvm{} API itself.
For instance,  we can determine the version with 
\Rfunc{llvmVersion}.
We can also determine which backend-targets were enabled
when the \llvm{} distribution was compiled and installed.
We do this with \Rfunc{getLLVMTargets}, which returns 
a character vector naming the different targets, e.g.
\begin{ROutput}
 [1] "X86"        "Sparc"      "PowerPC"    "AArch64"   
 [5] "ARM"        "Mips"       "XCore"      "MSP430"    
 [9] "CppBackend" "MBlaze"     "NVPTX"      "Hexagon"  
\end{ROutput}
We can enable any of these backends with a call to 
\Rfunc{Initialize*Target} where \texttt{*} is replaced
with the name of the target, e.g. \texttt{NVPTX}.


% Sharing code with other systems.
\section[Exporting compiled R functions to other languages]{Exporting compiled \R{} functions to other languages}

We started the technical part of this paper by importing either \IR{}
or bitcode into \R.  We can easily
export \llvm{} code we generate in \R{} and so make it available to other
systems such as \Python{} or \Matlab. Similarly, we can import \llvm{}
code generated in those systems. Once we compile one or more routines
in an \llvm{} module, we can write the module to either its \IR{} or
bitcode representation.  Just as we could read these into \R{} with
\Rfunc{parseIR} and \Rfunc{readBitcode}, these other systems can read
this code and invoke it directly.  This allows us to potentially
compile \R{} code directly to a form \llvm{} understands and export it
to another system which also understands this \llvm{} representation.


\section{Related Work}
Luke Tierney has developed a byte-code compiler for \R{} code
and extended the \R{} interpreter to evaluate that byte-code.

There are several projects the are implementing \R{} on the \Java{}
virtual machine.  These use just-in-time compilation to improve the
performance of code.

The \Rpkg{Rcpp} package and its related packages allow \R{}
programmers to write native code in \Cpp{} using classes and a
high-level syntax afforded by \Cpp{}.  These make the native code seem
more \R{}-like and easier to write.

\Rllvm{} differs from all of these as it does not directly attempt to
make \R{} code go faster. Instead, it is a general, infrastructural
tool with which I and others can try to make \R{} and other code
efficient, among other things. \Rpkg{RLLVMCompile} is an \R{} package
that implements a simple compilation strategy for some \R{} idioms.

The \Rpkg{r2c} package is an initial prototype of translating \R{}
code directly \C. In some ways, it is similar to \Rpkg{Rllvm} in that
it is compiling \R{} code. One difference is that the
translator/compiler is written in \C{} code.  This makes makes is
somewhat more difficult to adapt and extend.  The package generates
\C{} code and then calls a system compiler such as \gcc{} or \clang{}
to compile that code and so the user has a a choice of compiler.
\Rllvm{} is specific to \llvm{}.  While \llvm's IR code is
human-readable and portable and can be read on different machines in
different languages (e.g. \R, \Python), it is not a completely stable
and standardized format. Accordingly, exchanging \C{} code may be more
effective.  We can also use the regular system-level tools such as the
debugger to explore the generated code.  However, the \Rllvm{}
approach does allow us to use third-party, higher-level
representations representations of the compiled instructions than
string manipulation, e.g. the \Rclass{Module}, \Rclass{Function},
\Rclass{BasicBlock} and \Rclass{Instruction} objects.  We can query
and modify these in a more structured manner than string manipulation.
We are also hopeful that we will transparently benefit from any future
developments in the \llvm{} project.  Furthermore, while \llvm{} is
low-level, this potentially gives us greater control over the code we
generate.
% Different backends.



\section{Future Work}

We have manually created the bindings from \R{} to the \llvm{} API. We
created interfaces to the important classes and methods. As a result,
we plan to complete the bindings for the remaining aspects of the API.
We expect to do this primarily using an automated mechanism using the
\RClang{} package.

Debugging.
Associating with the original code.
%lldb


\bibliography{rllvm}
\end{document}
