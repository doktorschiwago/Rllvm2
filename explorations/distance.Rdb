<?xml version="1.0"?>
<article xmlns:r="http://www.r-project.org"
         xmlns:xi="http://www.w3.org/2003/XInclude">

<articleinfo>

<title>Computing Distances</title>

<author><firstname>Duncan</firstname><surname>Temple Lang</surname>
  <affiliation><orgname>University of California at Davis</orgname>
               <orgdiv>Department of Statistics</orgdiv>
  </affiliation>
</author>
</articleinfo>

<section>
<title></title>

<para>
Consider computing distances between all pairs of observations.
We can use the <r:func>dist</r:func> function in <r/> for this.
One thing to note about this function is that a) it
expects a single data frame, b) it computes all pairwise distances
for the observations in the data frame. 
This code is implemented in <c/>. 
If MPI is available, it uses parallel computations.
</para>

<para>
There are several issues we may want to change.  Firstly, we may have
two sets of observations in separate data frames. We have to combine
them into a single data frame or matrix to pass to
<r:func>dist</r:func>.  This involves creating a copy of the original
data sets, consuming more memory.  Secondly, we don't necessarily want
to compute all of the distances between all of the pairs of
observations. Often we only want to compute the distances between each
observation in the first data set and each of the observations in the
second.  We don't want to bother with the extra computation of the
distances of the within data set distances.  Another issue is that we
may want to use a different parallel strategy, e.g. multicore.  Also,
the <r:func>dist</r:func> function converts the observations to a
<r:class>matrix</r:class>. If the data were originally in a
<r:class>data.frame</r:class>, this creates yet another copy of the
data.  We don't want to have to write code that takes a data frame,
but we could.  Related to this is the fact that matrices are stored
column-wise So observations stored in rows have values that are not
conveniently and contiguously stored in memory. Instead, the elements
in each observation are separated by a stride given by the number of
rows.  This matters for accessing cached memory.  For a large number
of rows, the elements are further apart and so on different pages and
less likely to be together in the cache.  Instead, we'd like to be
able adapt the computations to improve the cache coherency, 
or at least easily explore the effect of the cache coherency.
</para>

<para>
The basic computations for computing the distance are  very simple:
compute the distance for each pair of observations by looping
over each set of observations.  The following <r/> code illustrates this:
<r:code>
<xi:include href="distance.R" parse="text"/>
</r:code>
Here we have two loops - over the pairs of observations. There is an
implicit third loop over the elements of the pairs of observations.
</para>


<para>
We have  a problem passing the array of values 
for each observation to our distance function.
In R, we pass g1[i,] and g2[j,].
R takes the time to create two new vectors
and then passes them to our function <r:func>op</r:func>.
Our <r:func>euclidean</r:func> function
<r:function><![CDATA[
function(x, y)
   sum((x - y)^2)
]]></r:function>
takes these and uses R's vectorization to loop 
</para>
<para>
We can write this euclidean distance as
<r:function><![CDATA[
function(x, y)
  Reduce(`+`, Map(`^`, Map(`-`, x, y), 2))
]]></r:function>
We can recognize this as and fuse the loops.
In the future, we will endeavor to recognize this in regular R code,
i.e. the original version.
</para>


<para>
Regardless of how we write the euclidean distance function for two observations,
the critical aspect is how they access the elements of the two observations.
What is key is that because we are compiling the euclidean function
for use in the distance function, we can arrange how the data are made
available and how that function accesses them. This gives us a great deal of freedom.
We can also compile different versions of our distance function and the 
<r:func>op</r:func> functions to work with data frames and so access the data in different
ways again.
</para>
<para>
We'll assume our two sets of observations are in matrices.
We will loop (i) over the rows of the first matrix
and for each of these, loop over the rows of the
other matrix. 
When we compute the distance for the i-th and j-th observations,
we loop over the elements of the matrices starting
 X + i and Y + j. The next pair of values is 
 X + i + nrow(X) and Y + j + nrow(Y).
 There are p iterations in this third loop.
</para>

<r:function><![CDATA[
dist = 
function(X, Y, nx = nrow(X), ny = nrow(Y), p = ncol(X), ans = numeric(nx * ny))
{
  ctr = 1L
  for(i in 1:nx) {
#    for(j in seq(i, length = ny - i + 1)) {
     for(j in 1:ny) {
#id = sprintf("%d.%d", i,j)
       total = 0.0
       posX = i
       posY = j
       for(k in 1:p) {
          total = total + (X[posX]  - Y[posY])^2
          posX = posX + nx
          posY = posY + ny
       }
       ans[ctr] = sqrt(total)
#       names(ans)[ctr] = id
       ctr = ctr + 1L
    }
  }
  ans
#  matrix(ans, nx, ny, byrow = TRUE)
}
]]></r:function>


<r:test><![CDATA[
X = matrix(rnorm(15), 3, 5)
Y = matrix(rnorm(20), 4, 5)
dist(X, Y)
as.matrix(stats::dist(rbind(X, Y)))[1:3, -(1:3)]

A = matrix(1:15, 3,5)
B = matrix(20:1, 4,5)
dist(A, B)
as.matrix(stats::dist(rbind(A, B)))[1:3, -(1:3)]
]]></r:test>


<r:code>
library(RLLVMCompile)
DoublePtrType = pointerType(DoubleType)
mod = Module()

distc = compileFunction(dist, REALSXPType, list(DoublePtrType, DoublePtrType, Int32Type, Int32Type, Int32Type, REALSXPType), module = mod)
</r:code>

</section>
</article>