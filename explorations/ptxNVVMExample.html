<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Compiling GPU Kernels in R Rllvm, Rnvvm and RCUDA</title><link rel="stylesheet" type="text/css" href="/Users/duncan/Classes/StatComputing/XDynDocs/inst/CSS/OmegaTech.css"></link><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"></meta></head><body class="yui-skin-sam"><div class="article" title="Compiling GPU Kernels in R Rllvm, Rnvvm and RCUDA"><div class="titlepage"><div><div><h2 class="title"><a id="id1168831279294"></a>Compiling GPU Kernels in <b xmlns:xd="http://www.xsldoc.org" xmlns="" class="proglang">R</b>
<br xmlns:xd="http://www.xsldoc.org" xmlns=""><a xmlns="" href="http://www.omegahat.org/Rllvm">Rllvm</a>,  <a xmlns="" href="http://www.omegahat.org/Rnvvm">Rnvvm</a> and <a xmlns="" href="http://www.omegahat.org/RCUDA">RCUDA</a>
</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Duncan</span> <span class="surname">Temple Lang</span></h3><div class="affiliation"><span class="orgname">University of California at Davis<br></br></span> <span class="orgdiv">Department of Statistics<br></br></span></div></div></div></div><hr></hr></div><p>
The idea here is to create a very, very simple kernel to run on a GPU.
We do this by creating individual instructions using
<a xmlns="" href="http://www.omegahat.org/Rllvm">Rllvm</a>.  When we have defined the routine, we use
the <b xmlns:c="http://www.C.org" xmlns:cpp="http://www.cplusplus.org" xmlns="" class="nativeLibrary">libnvvm</b> library via the <a xmlns="" href="http://www.omegahat.org/Rnvvm">Rnvvm</a> package
to transform the <a xmlns="" href="http://llvm.org">LLVM</a> IR code to PTX code.  We can then load this
PTX code into the <b xmlns:xd="http://www.xsldoc.org" xmlns="" class="proglang">R</b> session using the <a xmlns="" href="http://www.omegahat.org/RCUDA">RCUDA</a>
package and invoke the kernel.  This simple example illustrates all of
the steps we need to compile more complex <b xmlns:xd="http://www.xsldoc.org" xmlns="" class="proglang">R</b> code as GPU kernels
that we can then run directly from the <b xmlns:xd="http://www.xsldoc.org" xmlns="" class="proglang">R</b> session.
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="http://docbook.sourceforge.net/release/xsl/current/images/note.svg"></img></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p> <b xmlns:c="http://www.C.org" xmlns:cpp="http://www.cplusplus.org" xmlns="" class="nativeLibrary">libnvvm</b> is available in the current release
candidate version of the CUDA SDK, namely 5.5.
<a xmlns="" href="http://www.omegahat.org/Rllvm">Rllvm</a>, <a xmlns="" href="http://www.omegahat.org/RCUDA">RCUDA</a> and
<a xmlns="" href="http://www.omegahat.org/Rnvvm">Rnvvm</a> are available from github and also the
Omegahat repository.
</p></td></tr></table></div><div class="section" title="Generating the LLVM IR code"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id1168831332283"></a>Generating the <a xmlns="" href="http://llvm.org">LLVM</a> IR code</h2></div></div></div><p>
We start by creating the <a xmlns="" href="http://llvm.org">LLVM</a> instructions
to define our kernel. 
The kernel we want to implement is intentionally 
very, very simple and corresponds to the CUDA code
</p><pre xmlns="" class="C">
void kern(int N, int *out)
{
   int idx = blockIdx.x * blockDim.x + threadIdx.x;
   if(idx &lt; N)
     out[idx] = i;
}
</pre>
<p><br xmlns="">
This takes an array of integer values and 
each thread sets its (idx) element to <i xmlns:c="http://www.C.org" xmlns:cpp="http://www.cplusplus.org" xmlns="" class="cvariable">idx</i>
and we end up with 0, 1, 2, ...., N - 1 in <i xmlns:c="http://www.C.org" xmlns:cpp="http://www.cplusplus.org" xmlns="" class="cvariable">out</i>.
</p><p>
We could create the IR code by hand or generate this <b xmlns:xd="http://www.xsldoc.org" xmlns="" class="acronym" title="C programming language">C</b> (C programming language) code
and compile it. However, we want  to illustrate how to do this generally
and  be able to compile <b xmlns:xd="http://www.xsldoc.org" xmlns="" class="proglang">R</b>-like code to a kernel. For this, 
we use <a xmlns="" href="http://www.omegahat.org/Rllvm">Rllvm</a>.
We load that library and also  some simple utility functions
that will simplify our code generation and are generic
for <a xmlns="" href="http://llvm.org">LLVM</a> <i xmlns=""><a href="Help/Function-class.html">Function</a></i>s that we will convert
to PTX via <b xmlns:c="http://www.C.org" xmlns:cpp="http://www.cplusplus.org" xmlns="" class="nativeLibrary">libnvvm</b>.
</p><div xmlns="" class="codeToggle"><div class="unhidden" id="id1168831332337"><div><pre class="rcode" title="R code">
library(Rllvm)
source("nvvmUtils.R")
</pre></div></div></div>
<div xmlns="" class="clearFloat"></div>
<p>
</p><p>
We can now start to create our kernel.
We create a <i xmlns=""><a href="Help/Module-class.html">Module</a></i>.
Since we know we are targetting PTX code and <b xmlns:c="http://www.C.org" xmlns:cpp="http://www.cplusplus.org" xmlns="" class="nativeLibrary">libnvvm</b>,
we call <i xmlns:r="http://www.r-project.org" xmlns:s="http://cm.bell-labs.com/stat/S4" xmlns:py="http://www.python.org" xmlns:perl="http://www.perl.org" xmlns:c="http://www.C.org" xmlns:vb="http://www.visualbasic.com" xmlns:omegahat="http://www.omegahat.org" xmlns:bioc="http://www.bioconductor.org" xmlns:java="http://www.java.com" xmlns:sql="http://www.sql.org" xmlns="" class="rfunc">ModuleForNVVM()
</i> to create an
enhanced <i xmlns=""><a href="Help/Module-class.html">Module</a></i>:
</p><div xmlns="" class="codeToggle"><div class="unhidden" id="id1168831332357"><div><pre class="rcode" title="R code">
m = ModuleForNVVM("ptx kernel")
</pre></div></div></div>
<div xmlns="" class="clearFloat"></div>
<p>
This function sets the data layout string on the module and also
registers the special PTX register accessor routines so that we can
use them in our code.  These are the routines that correspond to
accessing the x, y, z components of <i xmlns:c="http://www.C.org" xmlns:cpp="http://www.cplusplus.org" xmlns="" class="cvariable">threadIdx</i>,
<i xmlns:c="http://www.C.org" xmlns:cpp="http://www.cplusplus.org" xmlns="" class="cvariable">blockIdx</i>, <i xmlns:c="http://www.C.org" xmlns:cpp="http://www.cplusplus.org" xmlns="" class="cvariable">gridIdx</i>,
<i xmlns:c="http://www.C.org" xmlns:cpp="http://www.cplusplus.org" xmlns="" class="cvariable">blockDim</i>, <i xmlns:c="http://www.C.org" xmlns:cpp="http://www.cplusplus.org" xmlns="" class="cvariable">gridDim</i>
</p><p>
With the module created, we define our new <i xmlns:r="http://www.r-project.org" xmlns:s="http://cm.bell-labs.com/stat/S4" xmlns:py="http://www.python.org" xmlns:perl="http://www.perl.org" xmlns:c="http://www.C.org" xmlns:vb="http://www.visualbasic.com" xmlns:omegahat="http://www.omegahat.org" xmlns:bioc="http://www.bioconductor.org" xmlns:java="http://www.java.com" xmlns:sql="http://www.sql.org" xmlns="" class="rfunc">Function()
</i>
which will become or GPU kernel.
</p><div xmlns="" class="codeToggle"><div class="unhidden" id="id1168831332386"><div><pre class="rcode" title="R code">
fun = simpleFunction("kern", VoidType, n = Int32Type, out = Int32PtrType, mod = m)
ir = fun$ir
localVars = fun$vars
fun = fun$fun
</pre></div></div></div>
<div xmlns="" class="clearFloat"></div>
<p>
We have used <i xmlns:r="http://www.r-project.org" xmlns:s="http://cm.bell-labs.com/stat/S4" xmlns:py="http://www.python.org" xmlns:perl="http://www.perl.org" xmlns:c="http://www.C.org" xmlns:vb="http://www.visualbasic.com" xmlns:omegahat="http://www.omegahat.org" xmlns:bioc="http://www.bioconductor.org" xmlns:java="http://www.java.com" xmlns:sql="http://www.sql.org" xmlns="" class="rfunc">simpleFunction()
</i>
in order to simplify creating the 
<i xmlns=""><a href="Help/IRBuilder-class.html">IRBuilder</a></i>, the
initial <i xmlns=""><a href="Help/BasicBlock-class.html">BasicBlock</a></i> and
also to create local variables corresponding to the parameters.
We could use <i xmlns:r="http://www.r-project.org" xmlns:s="http://cm.bell-labs.com/stat/S4" xmlns:py="http://www.python.org" xmlns:perl="http://www.perl.org" xmlns:c="http://www.C.org" xmlns:vb="http://www.visualbasic.com" xmlns:omegahat="http://www.omegahat.org" xmlns:bioc="http://www.bioconductor.org" xmlns:java="http://www.java.com" xmlns:sql="http://www.sql.org" xmlns="" class="rfunc">Function()
</i> directly.

</p><p>
In order to be able to use this routine as a GPU kernel,
we need to indicate that it is a kernel and not a device
or host routine. We do this by
adding metadata to the module that identifies this 
as a kernel. 
We do this with
</p><div xmlns="" class="codeToggle"><div class="unhidden" id="id1168831332410"><div><pre class="rcode" title="R code">
  # declare that this is a PTX kernel
setMetadata(m, "nvvm.annotations", list(fun, "kernel", 1L))
</pre></div></div></div>
<div xmlns="" class="clearFloat"></div>
<p>
We can define multiple kernels in the same module.
See <a class="ulink" href="http://llvm.org/docs/NVPTXUsage.html" target="_top">http://llvm.org/docs/NVPTXUsage.html</a> for more information.

</p><p>
We can now focus on implementing the routine.
The first step is to create
</p><pre xmlns="" class="C">
   int idx = blockIdx.x * blockDim.x + threadIdx.x;
</pre>
<p><br xmlns="">
The idea is that we will compute the index for this thread
and put that in a local variable <i xmlns:c="http://www.C.org" xmlns:cpp="http://www.cplusplus.org" xmlns="" class="cvariable">idx</i>.
We create the right-hand side
</p><div xmlns="" class="codeToggle"><div class="unhidden" id="id1168831332431"><div><pre class="rcode" title="R code">
blockId = ir$createCall(PTXRegisterRoutines[["llvm.nvvm.read.ptx.sreg.ctaid.x"]])
blockDim = ir$createCall(PTXRegisterRoutines[["llvm.nvvm.read.ptx.sreg.ntid.x"]])
mul = ir$binOp(Mul, blockId, blockDim)
threadId = ir$createCall(PTXRegisterRoutines[["llvm.nvvm.read.ptx.sreg.tid.x"]])
idx = ir$binOp(Add, mul, threadId)
</pre></div></div></div>
<div xmlns="" class="clearFloat"></div>
<p>
The important aspect of this is that we are accessing
<i xmlns:c="http://www.C.org" xmlns:cpp="http://www.cplusplus.org" xmlns="" class="cvariable">threadIdx.x</i>, for example, via
the <b xmlns="" class="$" title="">PTXRegisterRoutines</b> and the oddly named elements
<i xmlns="" class="relement">llvm.nvvm.read.ptx.sreg.tid.x</i>.
When we build a compiler  for creating GPU kernels, 
we'll allow the code to use <code xmlns="" class="Sexpression">threadIdx$x</code> and
map these expressions to calls to the corresponding register routine.

</p><p>
We can now create the local variable and initialize
it with the value of the right-hand side:
</p><div xmlns="" class="codeToggle"><div class="unhidden" id="id1168831332455"><div><pre class="rcode" title="R code">
i = ir$createLocalVariable(Int32Type, "idx")
ir$createStore(idx, i)
</pre></div></div></div>
<div xmlns="" class="clearFloat"></div>
<p>
Note that we are using the term idx in different ways here.
In the first expression, we are using it as the name 
in the <a xmlns="" href="http://llvm.org">LLVM</a> code. In the second expression, 
we are referring to the <b xmlns:xd="http://www.xsldoc.org" xmlns="" class="proglang">R</b> variable assigned in the
previous block of code that contains the addition of the two terms.
</p><p>
Our next step is to check if the value of <i xmlns:c="http://www.C.org" xmlns:cpp="http://www.cplusplus.org" xmlns="" class="cvariable">idx</i>
is less than our parameter </p><pre xmlns="" class="Carg">N</pre>
<p><br xmlns="">.
To do this, we need to create different blocks and conditionally
branch to the appropriate block.
One block will assign the value to the appropriate element in  our array
and jump to the end.
The other block will simply exit the kernel routine.
We create these blocks and the condition branch with 
</p><div xmlns="" class="codeToggle"><div class="unhidden" id="id1168831332480"><div><pre class="rcode" title="R code">
set = Block(fun, "set")
end = Block(fun, "return")

cond = ir$createICmp(ICMP_SLT, i, localVars$n)
ir$createCondBr(cond, set, end)
</pre></div></div></div>
<div xmlns="" class="clearFloat"></div>
<p>
</p><p>
We now implement the block that assigns the
value to the array.
We ensure we are adding code to this block and then use
a GEP instruction to access the relevant element of the array.

</p><div xmlns="" class="codeToggle"><div class="unhidden" id="id1168831332500"><div><pre class="rcode" title="R code">
ir$setInsertBlock(set)
gep = ir$createGEP(ir$createLoad(localVars$out), ir$createSExt(ir$createLoad(i), 64L))
ir$createStore(ir$createLoad(i), gep)
ir$createBr(end)
</pre></div></div></div>
<div xmlns="" class="clearFloat"></div>
<p>
The final command branches to the final block.
We could have, alternatively, added an explicit return here.
</p><p>
We can finish the code by adding a simple return 
to the final block:
</p><div xmlns="" class="codeToggle"><div class="unhidden" id="id1168831332509"><div><pre class="rcode" title="R code">
ir$setInsertBlock(end)
ir$createReturn()
</pre></div></div></div>
<div xmlns="" class="clearFloat"></div>
<p>
</p><p>
It is always a good idea to verify that the code in the module
is valid:
</p><div xmlns="" class="codeToggle"><div class="unhidden" id="id1168831332517"><div><pre class="rcode" title="R code">
verifyModule(m)
</pre></div></div></div>
<div xmlns="" class="clearFloat"></div>
<p>
</p></div><div class="section" title="Converting the IR code to PTX"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id1168831332522"></a>Converting the IR code to PTX</h2></div></div></div><p>
The next step in getting the code onto the GPU
is to convert the IR code to PTX code.
We can do this directly with <a xmlns="" href="http://llvm.org">LLVM</a>.
(See <code xmlns:r="http://www.r-project.org" xmlns:s="http://cm.bell-labs.com/stat/S4" xmlns:c="http://www.C.org" xmlns:python="http://www.python.org" xmlns:perl="http://www.perl.org" xmlns:vb="http://www.visualbasic.com" xmlns:omegahat="http://www.omegahat.org" xmlns:bioc="http://www.bioconductor.org" xmlns:java="http://www.java.com" xmlns:statdocs="http://www.statdocs.org" xmlns:gtk="http://www.gtk.org" xmlns:com="http://www.microsoft.com" xmlns:sh="http://www.shell.org" xmlns="" class="file">llvmPTXUtils.R</code> in this directory.)
However, <b xmlns:c="http://www.C.org" xmlns:cpp="http://www.cplusplus.org" xmlns="" class="nativeLibrary">libnvvm</b> does additional processing that
gets the code above to work.
We can use <b xmlns:c="http://www.C.org" xmlns:cpp="http://www.cplusplus.org" xmlns="" class="nativeLibrary">libnvvm</b> in <b xmlns:xd="http://www.xsldoc.org" xmlns="" class="proglang">R</b> via the
<a xmlns="" href="http://www.omegahat.org/Rnvvm">Rnvvm</a> package.
We get the IR code as a string 
and fix it up to remove <a xmlns="" href="http://llvm.org">LLVM</a>
attributes that <b xmlns:c="http://www.C.org" xmlns:cpp="http://www.cplusplus.org" xmlns="" class="nativeLibrary">libnvvm</b> doesn't currently understand.
(This may be due to  different versions of the <a xmlns="" href="http://llvm.org">LLVM</a> IR format.)
To convert the code, we use <i xmlns:r="http://www.r-project.org" xmlns:s="http://cm.bell-labs.com/stat/S4" xmlns:py="http://www.python.org" xmlns:perl="http://www.perl.org" xmlns:c="http://www.C.org" xmlns:vb="http://www.visualbasic.com" xmlns:omegahat="http://www.omegahat.org" xmlns:bioc="http://www.bioconductor.org" xmlns:java="http://www.java.com" xmlns:sql="http://www.sql.org" xmlns="" class="rfunc">generatePTX()
</i>:
</p><div xmlns="" class="codeToggle"><div class="unhidden" id="id1168831332562"><div><pre class="rcode" title="R code">
library(Rnvvm)
code = showModule(m, TRUE)
code = fixPTXCodeForNVVM(code)
ptx = generatePTX(code, isFile = FALSE)
</pre></div></div></div>
<div xmlns="" class="clearFloat"></div>
<p>
The <i xmlns:r="http://www.r-project.org" xmlns:s="http://cm.bell-labs.com/stat/S4" xmlns:py="http://www.python.org" xmlns:perl="http://www.perl.org" xmlns:c="http://www.C.org" xmlns:vb="http://www.visualbasic.com" xmlns:omegahat="http://www.omegahat.org" xmlns:bioc="http://www.bioconductor.org" xmlns:java="http://www.java.com" xmlns:sql="http://www.sql.org" xmlns="" class="rfunc">generatePTX()
</i> function in the <a xmlns="" href="http://www.omegahat.org/Rnvvm">Rnvvm</a>
is a high-level function that uses the lower-level
routines in the <b xmlns:c="http://www.C.org" xmlns:cpp="http://www.cplusplus.org" xmlns="" class="nativeLibrary">libnvvm</b> API.
The result is a string containing the entire PTX code corresponding
to our <a xmlns="" href="http://llvm.org">LLVM</a> module. We now have what we need to load onto the GPU.
</p></div><div class="section" title="Using the kernel on the GPU"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id1168831332582"></a>Using the kernel on the GPU</h2></div></div></div><p>
The final step is to load the PTX code and
invoke it from <b xmlns:xd="http://www.xsldoc.org" xmlns="" class="proglang">R</b>.
For this, we use the <a xmlns="" href="http://www.omegahat.org/RCUDA">RCUDA</a> package
and <i xmlns:r="http://www.r-project.org" xmlns:s="http://cm.bell-labs.com/stat/S4" xmlns:py="http://www.python.org" xmlns:perl="http://www.perl.org" xmlns:c="http://www.C.org" xmlns:vb="http://www.visualbasic.com" xmlns:omegahat="http://www.omegahat.org" xmlns:bioc="http://www.bioconductor.org" xmlns:java="http://www.java.com" xmlns:sql="http://www.sql.org" xmlns="" class="rfunc">cuModuleLoadDataEx()
</i>
</p><div xmlns="" class="codeToggle"><div class="unhidden" id="id1168831332599"><div><pre class="rcode" title="R code">
library(RCUDA)
cuda.mod = cuModuleLoadDataEx(ptx)
</pre></div></div></div>
<div xmlns="" class="clearFloat"></div>
<p>
</p><p>
We can now  invoke the kernel, passing it an array of integers
and the number of elements it contains.
We'll pass an <b xmlns:xd="http://www.xsldoc.org" xmlns="" class="proglang">R</b> vector  that has fewer  elements 
than the number of GPU threads we run.
This will exercise the condition in our code.
We'll run 32 x 32 threads. We'll pass a vector
with 100 fewer elements:
</p><div xmlns="" class="codeToggle"><div class="unhidden" id="id1168831332612"><div><pre class="rcode" title="R code">
n = 32^2
N = as.integer(n - 100L)
</pre></div></div></div>
<div xmlns="" class="clearFloat"></div>
<p>
We invoke this with 
</p><div xmlns="" class="codeToggle"><div class="unhidden" id="id1168831332616"><div><pre class="rcode" title="R code">
out = .gpu(cuda.mod$kern, N, ans = integer(N), outputs = "ans", gridDim = 1L, blockDim = c(32^2))
</pre></div></div></div>
<div xmlns="" class="clearFloat"></div>
<p>
We test the result is as we expect with
</p><div xmlns="" class="codeToggle"><div class="unhidden" id="id1168831332620"><div><pre class="rtest" title="R test">
stopifnot(identical(out, (1:N) - 1L))
</pre></div></div></div>
<div xmlns="" class="clearFloat"></div>
<p>
</p></div></div></body></html>
